\chapter*{Введение}\label{Input}
\addcontentsline{toc}{chapter}{Введение}

Ассоциативный массив - абстрактный тип данных (интерфейс к хра-
нилищу данных), позволяющий хранить пары вида ¾(ключ, значение)¿ и под-
держивающий операции добавления пары, а также поиска и удаления пары
по ключу:

\begin{enumerate}
  \item INSERT(ключ, значение)
  \item FIND(ключ)
  \item REMOVE(ключ)
\end{enumerate}

Предполагается, что ассоциативный массив не может хранить две па-
ры с одинаковыми ключами.
В паре (k, v) значение v называется значением, ассоциированным с
ключом k. Где k - это key, a v - value.
Операция FIND(ключ) возвращает значение, ассоциированное с за-
данным ключом, или некоторый специальный объект UNDEF, означающий,
что значения, ассоциированного с заданным ключом, нет. Две другие опера-
ции ничего не возвращают (за исключением, возможно, информации о том,
успешно ли была выполнена данная операция).
Ассоциативный массив с точки зрения интерфейса удобно рассматри-
вать как обычный массив, в котором в качестве индексов можно использовать
не только целые числа, но и значения других типов - например, строки.
Поддержка ассоциативных массивов есть во многих интерпретируе-
мых языках программирования высокого уровня, таких, как Perl, PHP, Python,
Ruby, Tcl, JavaScript и других. Для языков, которые не имеют встроенных
средств работы с ассоциативными массивами, существует множество реали-
заций в виде библиотек.
Примером ассоциативного массива является телефонный справочник:
значением в данном случае является совокупность "Ф. И. О. + адрес", а
ключом - номер телефона, один номер телефона имеет одного владельца, но
один человек может иметь несколько номеров.
Три основных операции часто дополняются другими, наиболее попу-
лярные расширения:

\begin{enumerate}
  \item CLEAR \ удалить все записи,
  \item EACH \ "пробежаться" по всем хранимым парам,
  \item MIN \ найти пару с минимальным значением ключа,
  \item MAX \ найти пару с максимальным значением ключа.
\end{enumerate}

В последних двух случаях необходимо, чтобы на ключах была опре-
делена операция сравнения.

Целью данной лабороторной работы является изучение способа эф-
фекливного по времени и памяти поиска по словарю. Задачами данной лабораторной являются:

\begin{enumerate}
  \item исследование алгоритмы поиска по словарю;
  %\item схемы рассматриваемых алгоритмов;
  \item проведение тестирования работы алгоритмов в лучшем, худшем и произвольном случае;
  \item замеры процессорного времени работы алгоритмов поиска пословарю для каждого ключа и для отсутствующего ключа, вывести минимальное, максимальное и среднее время поиска ключа;
  \item описание и обоснование полученных результатов в отчете о выполненной лабораторной работе, выполненного как расчетно-пояснительная 
  записка к работе.
\end{enumerate}

\chapter{Аналитическая часть}\label{Analis}
%\addcontentsline{toc}{chapter}{1 Аналитическая часть}

В данном разделе будут рассмотрены алгоритмы поиска в словаре: полный перебор, бинарный поиск, частотный анализ.

\section{Алгоритм полного перебора}\label{BubbleSort}

Идея алгоритма заключается в том, что поиск заданного элемента из
множества происходит непосредственно сравниванием каждого элемента этого множества с искомым, 
до тех пор, пока искомый не найдётся или множество не закончится.
Сложность алгоритма линейно зависит от объёма словаря, а время может стремиться к экспоненциальному времени работы.

\section{Алгоритм бинарного поиска}\label{ChoiseSort}

Данный алгоритм содержит в себе идею, которая заключается в том,
что берётся значение ключа из середины словаря и сравнивается с данным.
Если значение меньше (в контексте типа данных) данного, то продолжается
поиск в левой части словаря, при обратном случае - в правой. На новом интервале также берётся значение ключа из середины и сравнивается с данным.
Так продолжается до тех пор, пока найденное значение ключа не будет равно
данному.

Поиск в словаре с использованием данного алгоритма в худшем случае будет иметь трудоёмкость O(log2N ), что быстрее поиска при помощи
алгоритма полного перебора. Но стоит учитывать, что алгоритм бинарного
поиска работает только для заранее отсортированного словаря.
В случае большого объёма словаря и обратного порядка сортировки,
может произойти так, что алгоритм полного перебора будет эффективнее по
времени.

\section{Алгоритм частного анализа}\label{ChoiseSort}

Идея алгоритма заключается в составлении частотного анализа. Чтобы провести частотный анализ, 
необходимо взять первый элемент каждого
значения в словаре по ключу и подсчитать частотную характеристику, т.е.
сколько раз этот элемент встречается в качестве первого элемента. По полученным значениям словарь 
разбивается на сегменты так, что все элементы с одинаковым первым элементом оказываются в одном сегменте.
Далее сегменты упорядочиваются по значению частотной характеристики таким образом, чтобы элементы с наибольшей частотной
характеристикой был самый быстрый доступ.
Далее каждый сегмент упорядочивается по значению. Это необходимо
для реализации бинарного поиска, который обеспечит эффективный поиск в
сегменте при сложности O(N logN )

\section{Вывод аналитической части}\label{End_analis_chapter}

В данной работе стоит задача реализации следующих алгоритмов поиска по словарю: полный перебор, бинарный поиск, частотный анализ. 
Необходимо сравнить алгоритмы по эффективности по времени.
 
